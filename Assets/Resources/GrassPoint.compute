#pragma kernel CSMain

#include "Simplex.compute"

struct GrassData
{
    float4 position;
    float4 rotation;
};

RWStructuredBuffer<GrassData> _GrassBuffer;

uint _GridWidth, _GridHeight, _Dimension;
float _DisplacementStrength, _Spacing;

[numthreads(10, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    uint totalGrassInstances = _Dimension * 3;
    if (index >= totalGrassInstances)
        return;

    GrassData grass;

    // float4 pos = 0.0;
    // pos.xz = (id.xy - float(_Dimension) * 0.5) * (1.0 / float(_Spacing));

    uint x = int((index / 3u) % _GridWidth);
    uint z = int((index / 3u) / _GridHeight);
    grass.position = float4(x * _Spacing * 0.5, 0, z * _Spacing * 0.5, 0);

    float noiseX = snoise(float3(grass.position.x, 0, grass.position.z));
    float noiseY = snoise(float3(grass.position.x * 0.5, 0, grass.position.z * 0.5));
    float noiseZ = snoise(float3(grass.position.x * 0.5, 0, grass.position.z * 0.5));

    float noiseScale = 3.0;
    float minHeight = 0.5;
    float maxHeight = 1.0; 

    // Vary the height of the grass based on the noise values
    float height = minHeight + (maxHeight - minHeight) * (noiseX + noiseY + noiseZ) / noiseScale;

    float noise = abs(snoise(float3(grass.position.x, 0.0, grass.position.z) * 0.2));
    grass.position.w = lerp(0.3, 0.6, noise);

    // Apply the height variation
    grass.position.y += height + 0.5;




    if ((index % 3u) == 0)
    {
        grass.rotation = float4(0, 0, 0, 0); // No rotation
    }
    else if ((index % 3u) == 1)
    {
        grass.rotation = float4(0, 60, 0, 0); // 60 degrees rotation
    }
    else
    {
        grass.rotation = float4(0, -60, 0, 0); // -60 degrees rotation
    }

    _GrassBuffer[index] = grass;
}
