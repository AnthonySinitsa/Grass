#pragma kernel CSMain
#include "Random.cginc"

struct GrassBlade
{
    float3 position;
    float rotation;
    float height;
};

RWStructuredBuffer<GrassBlade> grassBuffer;

int numChunks, chunkDensity, seed;
float chunkSize;

[numthreads(10, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint totalGrassBlades = (uint)(numChunks * numChunks * chunkDensity * chunkDensity);
    if (id.x >= totalGrassBlades) return;

    GrassBlade blade;

    // Calculate chunk index and position within chunk
    uint chunkIndex = id.x / (chunkDensity * chunkDensity);
    uint bladeIndex = id.x % (chunkDensity * chunkDensity);

    int chunkX = chunkIndex % numChunks;
    int chunkZ = chunkIndex / numChunks;

    int bladeX = bladeIndex % chunkDensity;
    int bladeZ = bladeIndex / chunkDensity;

    // Initialize random number generator with a unique seed
    uint seed = id.x + 1;
    float randomX = randValue(seed) - 0.2;
    float randomZ = randValue(seed * 2) - 0.2;

    // Calculate world position and scale by chunk size, adding random offsets
    float3 position;
    position.x = chunkX * chunkSize + (bladeX * chunkSize) / chunkDensity + randomX * (chunkSize / chunkDensity);
    position.y = 0.5;
    position.z = chunkZ * chunkSize + (bladeZ * chunkSize) / chunkDensity + randomZ * (chunkSize / chunkDensity);

    // Calculate random rotation
    float rotation = randValue(seed * 3) * 360.0;

    // Voronoi noise calculation for clumping
    float3 clumpCenter = float3(floor(position.x / chunkSize) * chunkSize, 0, floor(position.z / chunkSize) * chunkSize);
    float3 nearestClumpCenter = clumpCenter;
    float minDist = length(position - clumpCenter);

    // Check neighboring clumps
    for (int dx = -1; dx <= 1; dx++)
    {
        for (int dz = -1; dz <= 1; dz++)
        {
            float3 neighborClumpCenter = clumpCenter + float3(dx * chunkSize, 0, dz * chunkSize);
            float dist = length(position - neighborClumpCenter);
            if (dist < minDist)
            {
                minDist = dist;
                nearestClumpCenter = neighborClumpCenter;
            }
        }
    }

    // Modify properties based on distance to nearest clump center
    float clumpFactor = 1.0 - saturate(minDist / chunkSize);
    blade.height = 0.5 + clumpFactor * 1.5; // Example: height varies between 0.5 and 2.0
    blade.rotation += clumpFactor * 45.0; // Example: rotation variation

    blade.position = position;
    blade.rotation = rotation;

    grassBuffer[id.x] = blade;
}